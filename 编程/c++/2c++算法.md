### 最大公因数
```
int gcd(int a,int b){
	while(b!=0){
		int temp=a%b;
		a=b;
		b=temp;
	}
	return a;
}
```
### 最小公倍数
```
int lcm(int a,int b){
	return a/gcd(a,b)*b;
}
```
# 数据结构
### 线性表
```C++
#include <iostream>
using namespace std;
// 链表结点
struct ListNode {
    int val;         // 结点值
    ListNode* next;  // 指向下一个结点的指针
    // 构造函数
    ListNode(int x) : val(x), next(nullptr) {}
};

// 链表类
class LinkedList {
private:
    ListNode* head;  // 头结点指针
    int size;       // 链表长度
public:
    // 构造函数
    LinkedList() : head(nullptr), size(0) {}
    
    // 析构函数 - 释放所有结点内存
    ~LinkedList() {
        ListNode* current = head;
        while (current != nullptr) {
            ListNode* next = current->next;
            delete current;
            current = next;
        }
    }
    
    // 在链表尾部添加结点
    void append(int val);
    // 在链表头部添加结点
    void prepend(int val) {
        ListNode* newNode = new ListNode(val);
        newNode->next = head;
        head = newNode;
        size++;
    }
    
    // 删除第一个匹配值的结点
    bool remove(int val) {
        if (head == nullptr) return false;
        
        if (head->val == val) {
            ListNode* toDelete = head;
            head = head->next;
            delete toDelete;
            size--;
            return true;
        }
        
        ListNode* current = head;
        while (current->next != nullptr) {
            if (current->next->val == val) {
                ListNode* toDelete = current->next;
                current->next = current->next->next;
                delete toDelete;
                size--;
                return true;
            }
            current = current->next;
        }
        
        return false;
    }
    
    // 获取链表长度
    int getSize() const {
        return size;
    }
    
    // 打印链表内容
    void print() const {
        ListNode* current = head;
        while (current != nullptr) {
            cout << current->val;
            if (current->next != nullptr) {
                cout << " -> ";
            }
            current = current->next;
        }
        cout << endl;
    }
};
void LinkedList::append(int val){
	ListNode* newNode = new ListNode(val);
        if (head == nullptr) {
            head = newNode;
        } else {
            ListNode* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
        size++;
}


int main() {
    LinkedList list;
    
    // 测试添加操作
    list.append(1);
    list.append(2);
    list.append(3);
    list.prepend(0);
    
    cout << "链表内容: ";
    list.print();  // 输出: 0 -> 1 -> 2 -> 3
    cout << "链表长度: " << list.getSize() << endl;  // 输出: 4
    
    // 测试删除操作
    list.remove(2);
    cout << "删除2后的链表: ";
    list.print();  // 输出: 0 -> 1 -> 3
    
    return 0;
}
```
### 栈
```C++
#include <iostream>
using namespace std;

// 链表结点
struct StackNode {
    int val;
    StackNode* next;
    StackNode(int x) : val(x), next(nullptr) {}
};

class LinkedListStack {
private:
    StackNode* topNode;  // 栈顶指针
    int stackSize;       // 栈的大小

public:
    LinkedListStack() : topNode(nullptr), stackSize(0) {}

    // 入栈
    void push(int val) {
        StackNode* newNode = new StackNode(val);
        newNode->next = topNode;  // 新结点指向原栈顶
        topNode = newNode;        // 更新栈顶
        stackSize++;
    }

    // 出栈
    int pop() {
        if (isEmpty()) {
            cout << "栈为空，无法出栈！" << endl;
            return -1;
        }
        StackNode* temp = topNode;
        int val = temp->val;
        topNode = topNode->next;  // 移动栈顶指针
        delete temp;              // 释放内存
        stackSize--;
        return val;
    }

    // 查看栈顶元素
    int peek() {
        if (isEmpty()) {
            cout << "栈为空！" << endl;
            return -1;
        }
        return topNode->val;
    }

    // 判断栈是否为空
    bool isEmpty() {
        return topNode == nullptr;
    }

    // 返回栈的大小
    int size() {
        return stackSize;
    }

    // 析构函数（防止内存泄漏）
    ~LinkedListStack() {
        while (!isEmpty()) {
            pop();
        }
    }
};

int main() {
    LinkedListStack stack;

    stack.push(100);
    stack.push(200);
    stack.push(300);

    cout << "栈大小: " << stack.size() << endl;    // 3
    cout << "栈顶元素: " << stack.peek() << endl;  // 300
    cout << "出栈: " << stack.pop() << endl;       // 300
    cout << "栈顶元素: " << stack.peek() << endl;  // 200

    return 0;
}
```
### 队
```C++
#include<iostream>
using namespace std;
struct Node{
	int val;
	Node* next=NULL;
	Node(int n){
		val=n;
	}
};
class Queue{
public:
	int capacity=0;
	Node* head=NULL;
	Node* tail=NULL;
	void Insert(int n){
		Node* newnode=new Node(n);
		if(capacity==0){
			tail=newnode;
			head=newnode;
		}
		else{
			tail->next=newnode;
			tail=newnode;
		}
		capacity++;
	}
	void pop(){
		if(tail==head){
			cout<<"失败";
			return ;
		}
		else{
			Node* todelete=head;
			head=head->next;
			delete todelete;
			capacity--;
		}
		if(capacity==0){
			tail=NULL;
		}
	}
	void peek(){
		cout<<head->val;
	}
	
	void printcapacity(){
		cout<<capacity;
	}
	void print(){
		Node* tempnode=head;
		while(tempnode!=tail){
			cout<<tempnode->val<<" ";
			tempnode=tempnode->next;
		}
		cout<<tempnode->val;
	}
};
int main(){
	Queue queue;
	queue.Insert(9);
	queue.Insert(10);
	queue.Insert(666);
	queue.pop();
	queue.print();
}
```
### 树
二叉搜索树
平衡二叉树
哈夫曼树
### 图
关键路径
最短路径
最小生成树
#  算法
### 排序算法
哈希
快排
堆排
归并
### 查找算法
折半查找
哈希表
